name: Validate Packages

on:
  push:
    paths:
      - 'packages/**/*.json'
      - '.github/workflows/validate-packages.yml'
  pull_request:
    paths:
      - 'packages/**/*.json'
  workflow_dispatch:  # Manual trigger
  schedule:
    # Run daily at 2 AM UTC to catch any issues
    - cron: '0 2 * * *'

jobs:
  validate-format:
    name: Validate Package Format
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Find all package files
        id: find-packages
        run: |
          echo "packages=$(find packages -name '*.json' -type f | sort | tr '\n' ' ')" >> $GITHUB_OUTPUT
          find packages -name '*.json' -type f | sort

      - name: Validate JSON syntax
        run: |
          echo "Validating JSON syntax for all package files..."
          FAILED=0
          for pkg in packages/*.json; do
            if [ -f "$pkg" ]; then
              echo "Checking: $pkg"
              if ! python3 -m json.tool "$pkg" > /dev/null 2>&1; then
                echo "❌ Invalid JSON syntax in $pkg"
                python3 -m json.tool "$pkg" 2>&1 || true
                FAILED=1
              else
                echo "✓ Valid JSON: $pkg"
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "::error::Some package files have invalid JSON syntax"
            exit 1
          fi
          echo "✓ All package files have valid JSON syntax"

      - name: Validate package structure
        run: |
          echo "Validating package structure..."
          FAILED=0
          
          for pkg in packages/*.json; do
            if [ -f "$pkg" ]; then
              echo "Validating structure: $pkg"
              
              # Check required fields
              REQUIRED_FIELDS=("name" "source")
              for field in "${REQUIRED_FIELDS[@]}"; do
                if ! python3 -c "import json, sys; data = json.load(open('$pkg')); sys.exit(0 if '$field' in data else 1)" 2>/dev/null; then
                  echo "❌ Missing required field '$field' in $pkg"
                  FAILED=1
                fi
              done
              
              # Validate source object
              if ! python3 -c "import json, sys; data = json.load(open('$pkg')); sys.exit(0 if isinstance(data.get('source'), dict) and 'type' in data.get('source', {}) and 'url' in data.get('source', {}) else 1)" 2>/dev/null; then
                echo "❌ Invalid or missing 'source' object in $pkg"
                echo "  Source must be an object with 'type' and 'url' fields"
                FAILED=1
              fi
              
              # Validate source type
              SOURCE_TYPE=$(python3 -c "import json; data = json.load(open('$pkg')); print(data.get('source', {}).get('type', ''))" 2>/dev/null)
              VALID_TYPES=("git" "tarball" "zip" "local")
              if [ -n "$SOURCE_TYPE" ] && [[ ! " ${VALID_TYPES[@]} " =~ " ${SOURCE_TYPE} " ]]; then
                echo "❌ Invalid source type '$SOURCE_TYPE' in $pkg"
                echo "  Valid types: ${VALID_TYPES[*]}"
                FAILED=1
              fi
              
              # Validate build_system if present
              BUILD_SYSTEM=$(python3 -c "import json; data = json.load(open('$pkg')); print(data.get('build_system', ''))" 2>/dev/null)
              if [ -n "$BUILD_SYSTEM" ]; then
                VALID_BUILD_SYSTEMS=("autotools" "cmake" "meson" "make" "cargo" "custom")
                if [[ ! " ${VALID_BUILD_SYSTEMS[@]} " =~ " ${BUILD_SYSTEM} " ]]; then
                  echo "❌ Invalid build_system '$BUILD_SYSTEM' in $pkg"
                  echo "  Valid build systems: ${VALID_BUILD_SYSTEMS[*]}"
                  FAILED=1
                fi
              fi
              
              # Validate arrays are actually arrays
              ARRAY_FIELDS=("dependencies" "build_dependencies" "configure_args" "cmake_args" "make_args" "patches")
              for field in "${ARRAY_FIELDS[@]}"; do
                if ! python3 -c "import json, sys; data = json.load(open('$pkg')); sys.exit(0 if '$field' not in data or isinstance(data.get('$field'), list) else 1)" 2>/dev/null; then
                  echo "❌ Field '$field' must be an array in $pkg"
                  FAILED=1
                fi
              done
              
              # Validate env is an object if present
              if ! python3 -c "import json, sys; data = json.load(open('$pkg')); sys.exit(0 if 'env' not in data or isinstance(data.get('env'), dict) else 1)" 2>/dev/null; then
                echo "❌ Field 'env' must be an object in $pkg"
                FAILED=1
              fi
              
              if [ $FAILED -eq 0 ]; then
                echo "✓ Valid structure: $pkg"
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "::error::Some package files have invalid structure"
            exit 1
          fi
          echo "✓ All package files have valid structure"

      - name: Check for duplicate package names
        run: |
          echo "Checking for duplicate package names..."
          python3 << 'EOF'
          import json
          import os
          from collections import Counter
          
          names = []
          for filename in os.listdir('packages'):
              if filename.endswith('.json'):
                  filepath = os.path.join('packages', filename)
                  try:
                      with open(filepath, 'r') as f:
                          data = json.load(f)
                          if 'name' in data:
                              names.append((data['name'], filepath))
                  except Exception as e:
                      print(f"Error reading {filepath}: {e}")
          
          name_counts = Counter([name for name, _ in names])
          duplicates = {name: count for name, count in name_counts.items() if count > 1}
          
          if duplicates:
              print("❌ Found duplicate package names:")
              for name, count in duplicates.items():
                  files = [path for n, path in names if n == name]
                  print(f"  '{name}' appears in {count} files:")
                  for f in files:
                      print(f"    - {f}")
              exit(1)
          else:
              print("✓ No duplicate package names found")
          EOF

  validate-tsi-parsing:
    name: Validate TSI Can Parse Packages
    runs-on: ubuntu-latest
    needs: validate-format
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build TSI
        run: |
          cd src
          make clean || true
          make

      - name: Test package parsing
        run: |
          echo "Testing if TSI can parse all package files..."
          FAILED=0
          
          for pkg in packages/*.json; do
            if [ -f "$pkg" ]; then
              PKG_NAME=$(basename "$pkg" .json)
              echo "Testing: $pkg"
              
              # Use TSI info command to test parsing
              if ./src/bin/tsi info "$PKG_NAME" > /dev/null 2>&1; then
                echo "✓ TSI can parse: $pkg"
              else
                echo "❌ TSI cannot parse: $pkg"
                ./src/bin/tsi info "$PKG_NAME" 2>&1 || true
                FAILED=1
              fi
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo "::error::TSI cannot parse some package files"
            exit 1
          fi
          echo "✓ TSI can parse all package files"

  validate-dependencies:
    name: Validate Package Dependencies
    runs-on: ubuntu-latest
    needs: validate-format
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate dependencies exist
        run: |
          echo "Validating that all dependencies reference existing packages..."
          python3 << 'EOF'
          import json
          import os
          import sys
          
          # Load all package names
          package_names = set()
          for filename in os.listdir('packages'):
              if filename.endswith('.json'):
                  filepath = os.path.join('packages', filename)
                  try:
                      with open(filepath, 'r') as f:
                          data = json.load(f)
                          if 'name' in data:
                              package_names.add(data['name'])
                  except Exception as e:
                      print(f"Error reading {filepath}: {e}")
          
          # Check dependencies
          failed = False
          for filename in os.listdir('packages'):
              if filename.endswith('.json'):
                  filepath = os.path.join('packages', filename)
                  try:
                      with open(filepath, 'r') as f:
                          data = json.load(f)
                          pkg_name = data.get('name', 'unknown')
                          
                          # Check dependencies
                          for dep_type in ['dependencies', 'build_dependencies']:
                              deps = data.get(dep_type, [])
                              for dep in deps:
                                  if dep not in package_names:
                                      print(f"❌ {pkg_name}: {dep_type} '{dep}' not found in packages/")
                                      failed = True
                          
                  except Exception as e:
                      print(f"Error reading {filepath}: {e}")
          
          if failed:
              print("\n::error::Some dependencies reference non-existent packages")
              sys.exit(1)
          else:
              print("✓ All dependencies reference existing packages")
          EOF

  test-package-install:
    name: Test Package Installation (Optional)
    runs-on: ubuntu-latest
    needs: [validate-format, validate-tsi-parsing, validate-dependencies]
    if: github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, '[test-install]')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build TSI in Docker
        run: |
          cd docker
          docker compose build alpine-c-only || docker-compose build alpine-c-only

      - name: Test installing a sample package
        run: |
          cd docker
          # Test installing a simple package (like zlib or pkg-config)
          docker compose run --rm --no-deps alpine-c-only sh -c "
            cd /root/tsi-source/src
            make clean || true
            make
            mkdir -p /root/.tsi/bin
            cp bin/tsi /root/.tsi/bin/
            export PATH=\"/root/.tsi/bin:\$PATH\"
            
            # Test installing a simple package
            echo 'Testing package installation...'
            tsi info zlib || echo 'Package zlib not found, skipping install test'
          " || docker-compose run --rm --no-deps alpine-c-only sh -c "
            cd /root/tsi-source/src
            make clean || true
            make
            mkdir -p /root/.tsi/bin
            cp bin/tsi /root/.tsi/bin/
            export PATH=\"/root/.tsi/bin:\$PATH\"
            
            echo 'Testing package installation...'
            tsi info zlib || echo 'Package zlib not found, skipping install test'
          "

